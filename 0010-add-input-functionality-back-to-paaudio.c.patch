From c2f6ffc3fe36fa139f175367350b06a0a36ae1fe Mon Sep 17 00:00:00 2001
From: Martin Schrodt <martin@schrodt.org>
Date: Tue, 10 Oct 2017 18:10:16 +0200
Subject: [PATCH 10/30] add input functionality back to paaudio.c

---
 audio/paaudio.c      | 296 ++++++++++++++++++++++++++++++++++++++++++++++-----
 hw/audio/hda-codec.c | 127 ++++++++++++++++------
 2 files changed, 367 insertions(+), 56 deletions(-)

diff --git a/audio/paaudio.c b/audio/paaudio.c
index 7c15b091fa..089af32e4d 100644
--- a/audio/paaudio.c
+++ b/audio/paaudio.c
@@ -23,7 +23,7 @@
  */
 #include "qemu/osdep.h"
 #include "audio.h"
-#include "hw/audio/intel-hda-defs.h"
+
 
 #include <pulse/pulseaudio.h>
 #include <include/qemu/timer.h>
@@ -34,8 +34,10 @@
 typedef struct {
     int buffer_size;
     int tlength;
+    int fragsize;
 #ifdef PA_STREAM_ADJUST_LATENCY
     int adjust_latency_out;
+    int adjust_latency_in;
 #endif
     char *server;
     char *sink;
@@ -52,8 +54,19 @@ typedef struct {
     HWVoiceOut hw;
     pa_stream *stream;
     paaudio *g;
+    pa_sample_spec ss;
+    pa_buffer_attr ba;
 } PAVoiceOut;
 
+typedef struct {
+    HWVoiceIn hw;
+    pa_stream *stream;
+    paaudio *g;
+    pa_sample_spec ss;
+    pa_buffer_attr ba;
+} PAVoiceIn;
+
+
 static void qpa_audio_fini(void *opaque);
 
 static void GCC_FMT_ATTR (2, 3) qpa_logerr (int err, const char *fmt, ...)
@@ -95,6 +108,7 @@ static inline int PA_STREAM_IS_GOOD(pa_stream_state_t x)
         }                                                       \
     } while (0);
 
+
 #define CHECK_DEAD_GOTO(c, stream, rerror, label)                       \
     do {                                                                \
         if (!(c)->context || !PA_CONTEXT_IS_GOOD (pa_context_get_state((c)->context)) || \
@@ -168,7 +182,6 @@ static int qpa_run_out (HWVoiceOut *hw, int live)
     fail:
     qpa_logerr (error, "qpa_run_out failed\n");
     goto bail;
-
 }
 
 static int qpa_write (SWVoiceOut *sw, void *buf, int len)
@@ -176,6 +189,93 @@ static int qpa_write (SWVoiceOut *sw, void *buf, int len)
     return audio_pcm_sw_write (sw, buf, len);
 }
 
+static int qpa_run_in (HWVoiceIn *hw)
+{
+    PAVoiceIn *pa = (PAVoiceIn *) hw;
+    int wpos, incr;
+    char *pa_src;
+    int error = 0;
+    int r;
+
+    incr = 0;
+    wpos = hw->wpos;
+
+    pa_threaded_mainloop_lock (pa->g->mainloop);
+    CHECK_DEAD_GOTO (pa->g, pa->stream, &error, fail);
+
+    size_t bytes_wanted = ((unsigned int)(hw->samples - audio_pcm_hw_get_live_in(hw)) << hw->info.shift);
+    if (bytes_wanted == 0) {
+        // no room
+        goto bail;
+    }
+
+    size_t bytes_avail = pa_stream_readable_size(pa->stream);
+
+    //dolog("WANT %d, HAVE %d\n", (int)bytes_wanted, (int) bytes_avail);
+
+    size_t pa_avail;
+
+    if (bytes_avail > bytes_wanted) {
+#if 0
+        size_t to_drop = bytes_avail - bytes_wanted;
+        while (to_drop) {
+            r = pa_stream_peek(pa->stream, (const void **)&pa_src, &pa_avail);
+            CHECK_SUCCESS_GOTO(pa->g, &error, r == 0, fail);
+            if (to_drop < pa_avail) {
+                break;
+            }
+            r = pa_stream_drop(pa->stream);
+            CHECK_SUCCESS_GOTO(pa->g, &error, r == 0, fail);
+            to_drop -= pa_avail;
+        }
+        int n_dropped = (int)(bytes_avail - bytes_wanted - to_drop);
+        if(n_dropped) {
+            dolog("dropped %d bytes\n", n_dropped);
+        }
+#endif
+    } else if (bytes_wanted < bytes_avail) {
+        bytes_wanted = bytes_avail;
+    }
+
+    while (bytes_wanted) {
+        r = pa_stream_peek(pa->stream, (const void **)&pa_src, &pa_avail);
+        CHECK_SUCCESS_GOTO(pa->g, &error, r == 0, fail);
+        if (pa_avail == 0 || pa_avail > bytes_wanted) {
+            break;
+        }
+
+        bytes_wanted -= pa_avail;
+
+        while (pa_avail) {
+            int chunk = audio_MIN ((int)(pa_avail >> hw->info.shift), hw->samples - wpos);
+            hw->conv (hw->conv_buf + wpos, pa_src, chunk);
+            wpos = (wpos + chunk) % hw->samples;
+            pa_src += chunk << hw->info.shift;
+            pa_avail -= chunk << hw->info.shift;
+            incr += chunk;
+        }
+
+        r = pa_stream_drop(pa->stream);
+        CHECK_SUCCESS_GOTO(pa->g, &error, r == 0, fail);
+    }
+
+    bail:
+    pa_threaded_mainloop_unlock (pa->g->mainloop);
+
+    hw->wpos = wpos;
+    return incr;
+
+    fail:
+    qpa_logerr (error, "qpa_run_in failed\n");
+    goto bail;
+
+}
+
+static int qpa_read (SWVoiceIn *sw, void *buf, int len)
+{
+    return audio_pcm_sw_read (sw, buf, len);
+}
+
 static pa_sample_format_t audfmt_to_pa (audfmt_e afmt, int endianness)
 {
     pa_sample_format_t format;
@@ -294,7 +394,7 @@ static pa_stream *qpa_simple_new (
         r = pa_stream_connect_record (stream, dev, attr,
                                       PA_STREAM_INTERPOLATE_TIMING
 #ifdef PA_STREAM_ADJUST_LATENCY
-                                      |PA_STREAM_ADJUST_LATENCY
+                                      | (g->conf.adjust_latency_in ? PA_STREAM_ADJUST_LATENCY : 0)
 #endif
                                       |PA_STREAM_AUTO_TIMING_UPDATE);
     }
@@ -324,8 +424,6 @@ static int qpa_init_out(HWVoiceOut *hw, struct audsettings *as,
                         void *drv_opaque)
 {
     int error;
-    pa_sample_spec ss;
-    pa_buffer_attr ba;
     struct audsettings obt_as = *as;
     PAVoiceOut *pa = (PAVoiceOut *) hw;
     paaudio *g = pa->g = drv_opaque;
@@ -348,35 +446,35 @@ static int qpa_init_out(HWVoiceOut *hw, struct audsettings *as,
           ((float) timer_tick_duration) / SCALE_MS,
           (float)frames_per_tick_x1000 / 1000.0f);
 
-    dolog("internal buffer: %.2f ms (%"PRId64" frames)\n",
+    dolog("OUT internal buffer: %.2f ms (%"PRId64" frames)\n",
           buflen * ms_per_frame,
           buflen);
 
-    dolog("tlength: %.2f ms (%"PRId64" frames)\n",
+    dolog("OUT tlength: %.2f ms (%"PRId64" frames)\n",
           tlength * ms_per_frame,
           tlength);
 
-    dolog("adjust latency: %s\n", g->conf.adjust_latency_out ? "yes" : "no");
+    dolog("OUT adjust latency: %s\n", g->conf.adjust_latency_out ? "yes" : "no");
 
-    ss.format = audfmt_to_pa (as->fmt, as->endianness);
-    ss.channels = as->nchannels;
-    ss.rate = as->freq;
+    pa->ss.format = audfmt_to_pa (as->fmt, as->endianness);
+    pa->ss.channels = as->nchannels;
+    pa->ss.rate = as->freq;
 
-    ba.tlength = tlength * pa_frame_size (&ss);
-    ba.maxlength = -1;
-    ba.minreq = -1;
-    ba.prebuf = -1;
+    pa->ba.tlength = tlength * pa_frame_size (&pa->ss);
+    pa->ba.maxlength = -1;
+    pa->ba.minreq = -1;
+    pa->ba.prebuf = -1;
 
-    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);
+    obt_as.fmt = pa_to_audfmt (pa->ss.format, &obt_as.endianness);
 
     pa->stream = qpa_simple_new (
         g,
         "qemu",
         PA_STREAM_PLAYBACK,
         g->conf.sink,
-        &ss,
+        &pa->ss,
         NULL,                   /* channel map */
-        &ba,                    /* buffering attributes */
+        &pa->ba,                /* buffering attributes */
         &error
         );
     if (!pa->stream) {
@@ -394,6 +492,74 @@ static int qpa_init_out(HWVoiceOut *hw, struct audsettings *as,
 }
 
 
+static int qpa_init_in(HWVoiceIn *hw, struct audsettings *as,
+                        void *drv_opaque)
+{
+    int error;
+    struct audsettings obt_as = *as;
+    PAVoiceIn *pa = (PAVoiceIn *) hw;
+    paaudio *g = pa->g = drv_opaque;
+
+    int64_t timer_tick_duration = audio_MAX(audio_get_timer_ticks(), 1 * SCALE_MS);
+    int64_t frames_per_tick_x1000 = ((timer_tick_duration * as->freq * 1000LL) / NANOSECONDS_PER_SECOND);
+
+    int64_t fragsize = g->conf.fragsize;
+    if (fragsize == 0) {
+        fragsize = frames_per_tick_x1000  / 2500;
+    }
+    int64_t buflen = g->conf.buffer_size;
+    if (buflen == 0) {
+        buflen = frames_per_tick_x1000  / 400;
+    }
+
+    float ms_per_frame = 1000.0f / as->freq;
+
+    dolog("IN internal buffer: %.2f ms (%"PRId64" frames)\n",
+          buflen * ms_per_frame,
+          buflen);
+
+    dolog("IN fragsize: %.2f ms (%"PRId64" frames)\n",
+          fragsize * ms_per_frame,
+          fragsize);
+
+    dolog("IN adjust latency: %s\n", g->conf.adjust_latency_in ? "yes" : "no");
+
+    pa->ss.format = audfmt_to_pa (as->fmt, as->endianness);
+    pa->ss.channels = as->nchannels;
+    pa->ss.rate = as->freq;
+
+    pa->ba.fragsize = fragsize * pa_frame_size (&pa->ss);
+    pa->ba.maxlength = pa->ba.fragsize * 10;
+    pa->ba.minreq = -1;
+    pa->ba.prebuf = -1;
+
+    obt_as.fmt = pa_to_audfmt (pa->ss.format, &obt_as.endianness);
+
+    pa->stream = qpa_simple_new (
+            g,
+            "qemu",
+            PA_STREAM_RECORD,
+            g->conf.source,
+            &pa->ss,
+            NULL,                   /* channel map */
+            &pa->ba,                /* buffering attributes */
+            &error
+    );
+    if (!pa->stream) {
+        qpa_logerr (error, "pa_simple_new for playback failed\n");
+        goto fail1;
+    }
+
+    audio_pcm_init_info (&hw->info, &obt_as);
+    hw->samples = buflen;
+
+    return 0;
+
+    fail1:
+    return -1;
+}
+
+
 static void qpa_fini_out (HWVoiceOut *hw)
 {
     PAVoiceOut *pa = (PAVoiceOut *) hw;
@@ -404,6 +570,16 @@ static void qpa_fini_out (HWVoiceOut *hw)
     }
 }
 
+static void qpa_fini_in (HWVoiceIn *hw)
+{
+    PAVoiceIn *pa = (PAVoiceIn *) hw;
+
+    if (pa->stream) {
+        pa_stream_unref (pa->stream);
+        pa->stream = NULL;
+    }
+}
+
 static int qpa_ctl_out (HWVoiceOut *hw, int cmd, ...)
 {
     PAVoiceOut *pa = (PAVoiceOut *) hw;
@@ -456,10 +632,64 @@ static int qpa_ctl_out (HWVoiceOut *hw, int cmd, ...)
     return 0;
 }
 
+static int qpa_ctl_in (HWVoiceIn *hw, int cmd, ...)
+{
+    PAVoiceIn *pa = (PAVoiceIn *) hw;
+    pa_operation *op;
+    pa_cvolume v;
+    paaudio *g = pa->g;
+
+#ifdef PA_CHECK_VERSION
+    pa_cvolume_init (&v);
+#endif
+
+    switch (cmd) {
+        case VOICE_VOLUME:
+        {
+            SWVoiceIn *sw;
+            va_list ap;
+
+            va_start (ap, cmd);
+            sw = va_arg (ap, SWVoiceIn *);
+            va_end (ap);
+
+            v.channels = 2;
+            v.values[0] = ((PA_VOLUME_NORM - PA_VOLUME_MUTED) * sw->vol.l) / UINT32_MAX;
+            v.values[1] = ((PA_VOLUME_NORM - PA_VOLUME_MUTED) * sw->vol.r) / UINT32_MAX;
+
+            pa_threaded_mainloop_lock (g->mainloop);
+
+            op = pa_context_set_source_output_volume (g->context,
+                                                      pa_stream_get_index (pa->stream),
+                                                      &v, NULL, NULL);
+            if (!op) {
+                qpa_logerr (pa_context_errno (g->context),
+                            "set_source_output_volume() failed\n");
+            } else {
+                pa_operation_unref(op);
+            }
+
+            op = pa_context_set_source_output_mute (g->context,
+                                                    pa_stream_get_index (pa->stream),
+                                                    sw->vol.mute, NULL, NULL);
+            if (!op) {
+                qpa_logerr (pa_context_errno (g->context),
+                            "set_source_output_mute() failed\n");
+            } else {
+                pa_operation_unref (op);
+            }
+
+            pa_threaded_mainloop_unlock (g->mainloop);
+        }
+    }
+    return 0;
+}
+
 /* common */
 static PAConf glob_conf = {
 #ifdef PA_STREAM_ADJUST_LATENCY
         .adjust_latency_out = 0,
+        .adjust_latency_in = 1,
 #endif
 };
 
@@ -560,12 +790,24 @@ struct audio_option qpa_options[] = {
         .valp  = &glob_conf.tlength,
         .descr = "playback buffer target length in frames"
     },
+    {
+        .name  = "FRAGSIZE",
+        .tag   = AUD_OPT_INT,
+        .valp  = &glob_conf.fragsize,
+        .descr = "fragment length of recording device in frames"
+    },
 #ifdef PA_STREAM_ADJUST_LATENCY
     {
-            .name  = "ADJUST_LATENCY_OUT",
-            .tag   = AUD_OPT_BOOL,
-            .valp  = &glob_conf.adjust_latency_out,
-            .descr = "let PA adjust latency for playback device"
+        .name  = "ADJUST_LATENCY_OUT",
+        .tag   = AUD_OPT_BOOL,
+        .valp  = &glob_conf.adjust_latency_out,
+        .descr = "let PA adjust latency for playback device"
+    },
+    {
+        .name  = "ADJUST_LATENCY_IN",
+        .tag   = AUD_OPT_BOOL,
+        .valp  = &glob_conf.adjust_latency_in,
+        .descr = "let PA adjust latency for recording device"
     },
 #endif
     {
@@ -595,6 +837,12 @@ static struct audio_pcm_ops qpa_pcm_ops = {
     .run_out  = qpa_run_out,
     .write    = qpa_write,
     .ctl_out  = qpa_ctl_out,
+
+    .init_in  = qpa_init_in,
+    .fini_in  = qpa_fini_in,
+    .run_in   = qpa_run_in,
+    .read     = qpa_read,
+    .ctl_in   = qpa_ctl_in
 };
 
 struct audio_driver pa_audio_driver = {
@@ -606,8 +854,8 @@ struct audio_driver pa_audio_driver = {
     .pcm_ops        = &qpa_pcm_ops,
     .can_be_default = 1,
     .max_voices_out = INT_MAX,
-    .max_voices_in  = 0,
+    .max_voices_in  = INT_MAX,
     .voice_size_out = sizeof (PAVoiceOut),
-    .voice_size_in  = 0,
+    .voice_size_in  = sizeof (PAVoiceIn),
     .ctl_caps       = VOICE_VOLUME_CAP
 };
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index 009d9bc2eb..760bfe40d4 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -18,6 +18,7 @@
  */
 
 #include "qemu/osdep.h"
+#include "qemu/atomic.h"
 #include "hw/hw.h"
 #include "hw/pci/pci.h"
 #include "intel-hda.h"
@@ -179,30 +180,91 @@ struct HDAAudioState {
     bool     mixer;
 };
 
+static void hda_audio_input_timer(void *opaque) {
+
+#define B_SIZE sizeof(st->buf)
+#define B_MASK (sizeof(st->buf) - 1)
+
+    HDAAudioStream *st = opaque;
+
+    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
+
+    int64_t buft_start = atomic_fetch_add(&st->buft_start, 0);
+    int64_t wpos = atomic_fetch_add(&st->wpos, 0);
+    int64_t rpos = atomic_fetch_add(&st->rpos, 0);
+
+    int64_t wanted_rpos = (st->as.freq * 4 * (now - buft_start)) / NANOSECONDS_PER_SECOND;
+    wanted_rpos &= -4; // IMPORTANT! clip to frames
+
+    if (wanted_rpos <= rpos) {
+        // we already transmitted the data
+        goto out_timer;
+    }
+
+    if (wpos - rpos >= B_SIZE) {
+        goto out_timer;
+    }
+
+    //dolog("%"PRId64"\n", wpos - rpos);
+
+    //dolog("rpos: %"PRId64", wpos: %"PRId64", wanted: %"PRId64"\n", rpos, wpos, wanted_wpos);
+    int64_t to_transfer = audio_MIN(B_SIZE - (wpos - rpos), wanted_rpos - rpos);
+    while (to_transfer) {
+        uint32_t start = (rpos & B_MASK);
+        uint32_t chunk = audio_MIN(B_SIZE - start, to_transfer);
+        int rc = hda_codec_xfer(&st->state->hda, st->stream, false, st->buf + start, chunk);
+        if (!rc) {
+            break;
+        }
+        rpos += chunk;
+        to_transfer -= chunk;
+        atomic_fetch_add(&st->rpos, chunk);
+    }
+
+#undef B_MASK
+#undef B_SIZE
+
+    out_timer:
+
+    if (st->running) {
+        timer_mod_anticipate_ns(st->buft, now + HDA_TIMER_TICKS);
+    }
+}
+
+
 static void hda_audio_input_cb(void *opaque, int avail)
 {
-//    HDAAudioStream *st = opaque;
-//    int recv = 0;
-//    int len;
-//    bool rc;
-//
-//    while (avail - recv >= sizeof(st->buf)) {
-//        if (st->bpos != sizeof(st->buf)) {
-//            len = AUD_read(st->voice.in, st->buf + st->bpos,
-//                           sizeof(st->buf) - st->bpos);
-//            st->bpos += len;
-//            recv += len;
-//            if (st->bpos != sizeof(st->buf)) {
-//                break;
-//            }
-//        }
-//        rc = hda_codec_xfer(&st->state->hda, st->stream, false,
-//                            st->buf, sizeof(st->buf));
-//        if (!rc) {
-//            break;
-//        }
-//        st->bpos = 0;
+#define B_SIZE sizeof(st->buf)
+#define B_MASK (sizeof(st->buf) - 1)
+
+    HDAAudioStream *st = opaque;
+
+    int64_t wpos = atomic_fetch_add(&st->wpos, 0);
+    int64_t rpos = atomic_fetch_add(&st->rpos, 0);
+
+    int64_t to_transfer = audio_MIN(wpos - rpos, avail);
+
+//    int64_t overflow = wpos - rpos - to_transfer - (B_SIZE >> 3);
+//    if (overflow > 0) {
+//        int64_t corr = NANOSECONDS_PER_SECOND * overflow / (4 * st->as.freq);
+//        //dolog("CORR %"PRId64"\n", corr);
+//        atomic_fetch_add(&st->buft_start, corr);
 //    }
+
+    while (to_transfer) {
+        uint32_t start = (uint32_t) (wpos & B_MASK);
+        uint32_t chunk = (uint32_t) audio_MIN(B_SIZE - start, to_transfer);
+        uint32_t read = AUD_read(st->voice.in, st->buf + start, chunk);
+        wpos += read;
+        to_transfer -= read;
+        atomic_fetch_add(&st->wpos, read);
+        if (chunk != read) {
+            break;
+        }
+    }
+
+#undef B_MASK
+#undef B_SIZE
 }
 
 
@@ -217,14 +279,15 @@ static void hda_audio_output_timer(void *opaque) {
 
     int64_t now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
 
-    int64_t wanted_wpos = (st->as.freq * 4 * (now - st->buft_start)) / NANOSECONDS_PER_SECOND;
-    wanted_wpos &= -4; // IMPORTANT! clip to frames
+    int64_t buft_start = atomic_fetch_add(&st->buft_start, 0);
+    int64_t wpos = atomic_fetch_add(&st->wpos, 0);
+    int64_t rpos = atomic_fetch_add(&st->rpos, 0);
 
-    int64_t wpos = st->wpos;
-    int64_t rpos = st->rpos;
+    int64_t wanted_wpos = (st->as.freq * 4 * (now - buft_start)) / NANOSECONDS_PER_SECOND;
+    wanted_wpos &= -4; // IMPORTANT! clip to frames
 
     if (wanted_wpos <= wpos) {
-        // we already have the data
+        // we already received the data
         goto out_timer;
     }
 
@@ -245,8 +308,8 @@ static void hda_audio_output_timer(void *opaque) {
         }
         wpos += chunk;
         to_transfer -= chunk;
+        atomic_fetch_add(&st->wpos, chunk);
     }
-    st->wpos = wpos;
 
 #undef B_MASK
 #undef B_SIZE
@@ -265,8 +328,8 @@ static void hda_audio_output_cb(void *opaque, int avail)
 
     HDAAudioStream *st = opaque;
 
-    int64_t wpos = st->wpos;
-    int64_t rpos = st->rpos;
+    int64_t wpos = atomic_fetch_add(&st->wpos, 0);
+    int64_t rpos = atomic_fetch_add(&st->rpos, 0);
 
     int64_t to_transfer = audio_MIN(wpos - rpos, avail);
 
@@ -274,7 +337,7 @@ static void hda_audio_output_cb(void *opaque, int avail)
     if (overflow > 0) {
         int64_t corr = NANOSECONDS_PER_SECOND * overflow / (4 * st->as.freq);
         //dolog("CORR %"PRId64"\n", corr);
-        st->buft_start += corr;
+        atomic_fetch_add(&st->buft_start, corr);
     }
 
     while (to_transfer) {
@@ -283,13 +346,12 @@ static void hda_audio_output_cb(void *opaque, int avail)
         uint32_t written = AUD_write(st->voice.out, st->buf + start, chunk);
         rpos += written;
         to_transfer -= written;
+        atomic_fetch_add(&st->rpos, written);
         if (chunk != written) {
             break;
         }
     }
 
-    st->rpos = rpos;
-
 #undef B_MASK
 #undef B_SIZE
 }
@@ -368,6 +430,7 @@ static void hda_audio_setup(HDAAudioStream *st)
         st->voice.in = AUD_open_in(&st->state->card, st->voice.in,
                                    st->node->name, st,
                                    hda_audio_input_cb, &st->as);
+        st->buft = timer_new_ns(QEMU_CLOCK_VIRTUAL, hda_audio_input_timer, st);
     }
 }
 
-- 
2.15.0

