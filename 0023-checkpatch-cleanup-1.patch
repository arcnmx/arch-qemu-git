From 1a3d48b64b821ea15f872579e964531afdc073c3 Mon Sep 17 00:00:00 2001
From: Martin Schrodt <martin@schrodt.org>
Date: Sun, 15 Oct 2017 17:46:03 +0200
Subject: [PATCH 23/30] checkpatch cleanup 1

Signed-off-by: Martin Schrodt <martin@schrodt.org>
---
 audio/audio.c   |   3 +-
 audio/paaudio.c | 366 ++++++++++++++++++++++++++++----------------------------
 2 files changed, 185 insertions(+), 184 deletions(-)

diff --git a/audio/audio.c b/audio/audio.c
index fba1604c34..6f42a019b0 100644
--- a/audio/audio.c
+++ b/audio/audio.c
@@ -2067,6 +2067,7 @@ void AUD_set_volume_in (SWVoiceIn *sw, int mute, uint8_t lvol, uint8_t rvol)
     }
 }
 
-int64_t audio_get_timer_ticks(void) {
+int64_t audio_get_timer_ticks(void)
+{
     return conf.period.ticks;
 }
diff --git a/audio/paaudio.c b/audio/paaudio.c
index 3d24712483..b180d213cb 100644
--- a/audio/paaudio.c
+++ b/audio/paaudio.c
@@ -104,7 +104,7 @@ static inline int PA_STREAM_IS_GOOD(pa_stream_state_t x)
         }                                                               \
     } while (0);
 
-static int qpa_run_out (HWVoiceOut *hw, int live)
+static int qpa_run_out(HWVoiceOut *hw, int live)
 {
     PAVoiceOut *pa = (PAVoiceOut *) hw;
     int rpos, decr, samples;
@@ -149,14 +149,14 @@ static int qpa_run_out (HWVoiceOut *hw, int live)
         decr += convert_samples;
     }
 
-bail:
+    bail:
     pa_threaded_mainloop_unlock(pa->g->mainloop);
 
-hw->rpos = rpos;
+    hw->rpos = rpos;
     return decr;
 
     fail:
-    qpa_logerr (error, "qpa_run_out failed\n");
+    qpa_logerr(error, "qpa_run_out failed\n");
     goto bail;
 }
 
@@ -165,7 +165,7 @@ static int qpa_write (SWVoiceOut *sw, void *buf, int len)
     return audio_pcm_sw_write (sw, buf, len);
 }
 
-static int qpa_run_in (HWVoiceIn *hw)
+static int qpa_run_in(HWVoiceIn *hw)
 {
     PAVoiceIn *pa = (PAVoiceIn *) hw;
     int wpos, incr;
@@ -182,7 +182,7 @@ static int qpa_run_in (HWVoiceIn *hw)
 
     size_t bytes_wanted = ((unsigned int)(hw->samples - audio_pcm_hw_get_live_in(hw)) << hw->info.shift);
     if (bytes_wanted == 0) {
-        // no room
+        /* no room */
         goto bail;
     }
 
@@ -215,14 +215,14 @@ static int qpa_run_in (HWVoiceIn *hw)
         CHECK_SUCCESS_GOTO(pa->g, rerror, r == 0, fail);
     }
 
-bail:
+    bail:
     pa_threaded_mainloop_unlock(pa->g->mainloop);
 
     hw->wpos = wpos;
     return incr;
 
-fail:
-    qpa_logerr (error, "qpa_run_in failed\n");
+    fail:
+    qpa_logerr(error, "qpa_run_in failed\n");
     goto bail;
 }
 
@@ -236,22 +236,22 @@ static pa_sample_format_t audfmt_to_pa (audfmt_e afmt, int endianness)
     int format;
 
     switch (afmt) {
-    case AUD_FMT_S8:
-    case AUD_FMT_U8:
-        format = PA_SAMPLE_U8;
-        break;
-    case AUD_FMT_S16:
-    case AUD_FMT_U16:
-        format = endianness ? PA_SAMPLE_S16BE : PA_SAMPLE_S16LE;
-        break;
-    case AUD_FMT_S32:
-    case AUD_FMT_U32:
-        format = endianness ? PA_SAMPLE_S32BE : PA_SAMPLE_S32LE;
-        break;
-    default:
-        dolog ("Internal logic error: Bad audio format %d\n", afmt);
-        format = PA_SAMPLE_U8;
-        break;
+        case AUD_FMT_S8:
+        case AUD_FMT_U8:
+            format = PA_SAMPLE_U8;
+            break;
+        case AUD_FMT_S16:
+        case AUD_FMT_U16:
+            format = endianness ? PA_SAMPLE_S16BE : PA_SAMPLE_S16LE;
+            break;
+        case AUD_FMT_S32:
+        case AUD_FMT_U32:
+            format = endianness ? PA_SAMPLE_S32BE : PA_SAMPLE_S32LE;
+            break;
+        default:
+            dolog ("Internal logic error: Bad audio format %d\n", afmt);
+            format = PA_SAMPLE_U8;
+            break;
     }
     return format;
 }
@@ -259,23 +259,23 @@ static pa_sample_format_t audfmt_to_pa (audfmt_e afmt, int endianness)
 static audfmt_e pa_to_audfmt (pa_sample_format_t fmt, int *endianness)
 {
     switch (fmt) {
-    case PA_SAMPLE_U8:
-        return AUD_FMT_U8;
-    case PA_SAMPLE_S16BE:
-        *endianness = 1;
-        return AUD_FMT_S16;
-    case PA_SAMPLE_S16LE:
-        *endianness = 0;
-        return AUD_FMT_S16;
-    case PA_SAMPLE_S32BE:
-        *endianness = 1;
-        return AUD_FMT_S32;
-    case PA_SAMPLE_S32LE:
-        *endianness = 0;
-        return AUD_FMT_S32;
-    default:
-        dolog ("Internal logic error: Bad pa_sample_format %d\n", fmt);
-        return AUD_FMT_U8;
+        case PA_SAMPLE_U8:
+            return AUD_FMT_U8;
+        case PA_SAMPLE_S16BE:
+            *endianness = 1;
+            return AUD_FMT_S16;
+        case PA_SAMPLE_S16LE:
+            *endianness = 0;
+            return AUD_FMT_S16;
+        case PA_SAMPLE_S32BE:
+            *endianness = 1;
+            return AUD_FMT_S32;
+        case PA_SAMPLE_S32LE:
+            *endianness = 0;
+            return AUD_FMT_S32;
+        default:
+            dolog ("Internal logic error: Bad pa_sample_format %d\n", fmt);
+            return AUD_FMT_U8;
     }
 }
 
@@ -284,17 +284,17 @@ static void context_state_cb (pa_context *c, void *userdata)
     paaudio *g = userdata;
 
     switch (pa_context_get_state(c)) {
-    case PA_CONTEXT_READY:
-    case PA_CONTEXT_TERMINATED:
-    case PA_CONTEXT_FAILED:
-        pa_threaded_mainloop_signal (g->mainloop, 0);
-        break;
-
-    case PA_CONTEXT_UNCONNECTED:
-    case PA_CONTEXT_CONNECTING:
-    case PA_CONTEXT_AUTHORIZING:
-    case PA_CONTEXT_SETTING_NAME:
-        break;
+        case PA_CONTEXT_READY:
+        case PA_CONTEXT_TERMINATED:
+        case PA_CONTEXT_FAILED:
+            pa_threaded_mainloop_signal (g->mainloop, 0);
+            break;
+
+        case PA_CONTEXT_UNCONNECTED:
+        case PA_CONTEXT_CONNECTING:
+        case PA_CONTEXT_AUTHORIZING:
+        case PA_CONTEXT_SETTING_NAME:
+            break;
     }
 }
 
@@ -304,15 +304,15 @@ static void stream_state_cb (pa_stream *s, void * userdata)
 
     switch (pa_stream_get_state (s)) {
 
-    case PA_STREAM_READY:
-    case PA_STREAM_FAILED:
-    case PA_STREAM_TERMINATED:
-        pa_threaded_mainloop_signal (g->mainloop, 0);
-        break;
+        case PA_STREAM_READY:
+        case PA_STREAM_FAILED:
+        case PA_STREAM_TERMINATED:
+            pa_threaded_mainloop_signal (g->mainloop, 0);
+            break;
 
-    case PA_STREAM_UNCONNECTED:
-    case PA_STREAM_CREATING:
-        break;
+        case PA_STREAM_UNCONNECTED:
+        case PA_STREAM_CREATING:
+            break;
     }
 }
 
@@ -351,14 +351,14 @@ static pa_stream *qpa_simple_new (
     }
 
     if (r < 0) {
-      goto fail;
+        goto fail;
     }
 
     pa_threaded_mainloop_unlock (g->mainloop);
 
     return stream;
 
-fail:
+    fail:
     pa_threaded_mainloop_unlock (g->mainloop);
 
     if (stream) {
@@ -391,20 +391,20 @@ static int qpa_init_out(HWVoiceOut *hw, struct audsettings *as,
     }
 
     ldebug("tick duration: %.2f ms (%.3f frames)\n",
-          ((float)timer_tick_duration) / SCALE_MS,
-          (float)frames_per_tick_x1000 / 1000.0f);
+           ((float)timer_tick_duration) / SCALE_MS,
+           (float)frames_per_tick_x1000 / 1000.0f);
 
     ldebug("OUT internal buffer: %.2f ms (%"PRId64" frames)\n",
-          buflen * (1000.0f / as->freq),
-          buflen);
+           buflen * (1000.0f / as->freq),
+           buflen);
 
     ldebug("OUT tlength: %.2f ms (%"PRId64" frames)\n",
-          tlength * (1000.0f / as->freq),
-          tlength);
+           tlength * (1000.0f / as->freq),
+           tlength);
 
     ldebug("OUT adjust latency: %s\n", g->conf.adjust_latency_out ? "yes" : "no");
 
-    pa->ss.format = audfmt_to_pa (as->fmt, as->endianness);
+    pa->ss.format = audfmt_to_pa(as->fmt, as->endianness);
     pa->ss.channels = as->nchannels;
     pa->ss.rate = as->freq;
 
@@ -413,9 +413,9 @@ static int qpa_init_out(HWVoiceOut *hw, struct audsettings *as,
     pa->ba.minreq = -1;
     pa->ba.prebuf = -1;
 
-    obt_as.fmt = pa_to_audfmt (pa->ss.format, &obt_as.endianness);
+    obt_as.fmt = pa_to_audfmt(pa->ss.format, &obt_as.endianness);
 
-    pa->stream = qpa_simple_new (
+    pa->stream = qpa_simple_new(
             g,
             "qemu",
             PA_STREAM_PLAYBACK,
@@ -430,12 +430,12 @@ static int qpa_init_out(HWVoiceOut *hw, struct audsettings *as,
         goto fail1;
     }
 
-    audio_pcm_init_info (&hw->info, &obt_as);
+    audio_pcm_init_info(&hw->info, &obt_as);
     hw->samples = buflen;
 
     return 0;
 
-fail1:
+    fail1:
     return -1;
 }
 
@@ -465,31 +465,31 @@ static int qpa_init_in(HWVoiceIn *hw, struct audsettings *as,
     }
 
     ldebug("IN internal buffer: %.2f ms (%"PRId64" frames)\n",
-          buflen * (1000.0f / as->freq),
-          buflen);
+           buflen * (1000.0f / as->freq),
+           buflen);
 
     ldebug("IN fragsize: %.2f ms (%"PRId64" frames)\n",
-          fragsize * (1000.0f / as->freq),
-          fragsize);
+           fragsize * (1000.0f / as->freq),
+           fragsize);
 
     ldebug("IN maxlength: %.2f ms (%"PRId64" frames)\n",
-          maxlength * (1000.0f / as->freq),
-          maxlength);
+           maxlength * (1000.0f / as->freq),
+           maxlength);
 
     ldebug("IN adjust latency: %s\n", g->conf.adjust_latency_in ? "yes" : "no");
 
-    pa->ss.format = audfmt_to_pa (as->fmt, as->endianness);
+    pa->ss.format = audfmt_to_pa(as->fmt, as->endianness);
     pa->ss.channels = as->nchannels;
     pa->ss.rate = as->freq;
 
-    pa->ba.fragsize = fragsize * pa_frame_size (&pa->ss);
-    pa->ba.maxlength = maxlength * pa_frame_size (&pa->ss);
+    pa->ba.fragsize = fragsize * pa_frame_size(&pa->ss);
+    pa->ba.maxlength = maxlength * pa_frame_size(&pa->ss);
     pa->ba.minreq = -1;
     pa->ba.prebuf = -1;
 
-    obt_as.fmt = pa_to_audfmt (pa->ss.format, &obt_as.endianness);
+    obt_as.fmt = pa_to_audfmt(pa->ss.format, &obt_as.endianness);
 
-    pa->stream = qpa_simple_new (
+    pa->stream = qpa_simple_new(
             g,
             "qemu",
             PA_STREAM_RECORD,
@@ -504,12 +504,12 @@ static int qpa_init_in(HWVoiceIn *hw, struct audsettings *as,
         goto fail1;
     }
 
-    audio_pcm_init_info (&hw->info, &obt_as);
+    audio_pcm_init_info(&hw->info, &obt_as);
     hw->samples = buflen;
 
     return 0;
 
-fail1:
+    fail1:
     return -1;
 }
 
@@ -545,7 +545,7 @@ static int qpa_ctl_out (HWVoiceOut *hw, int cmd, ...)
 #endif
 
     switch (cmd) {
-    case VOICE_VOLUME:
+        case VOICE_VOLUME:
         {
             SWVoiceOut *sw;
             va_list ap;
@@ -561,8 +561,8 @@ static int qpa_ctl_out (HWVoiceOut *hw, int cmd, ...)
             pa_threaded_mainloop_lock (g->mainloop);
 
             op = pa_context_set_sink_input_volume (g->context,
-                pa_stream_get_index (pa->stream),
-                &v, NULL, NULL);
+                                                   pa_stream_get_index (pa->stream),
+                                                   &v, NULL, NULL);
             if (!op)
                 qpa_logerr (pa_context_errno (g->context),
                             "set_sink_input_volume() failed\n");
@@ -570,8 +570,8 @@ static int qpa_ctl_out (HWVoiceOut *hw, int cmd, ...)
                 pa_operation_unref (op);
 
             op = pa_context_set_sink_input_mute (g->context,
-                pa_stream_get_index (pa->stream),
-               sw->vol.mute, NULL, NULL);
+                                                 pa_stream_get_index (pa->stream),
+                                                 sw->vol.mute, NULL, NULL);
             if (!op) {
                 qpa_logerr (pa_context_errno (g->context),
                             "set_sink_input_mute() failed\n");
@@ -597,7 +597,7 @@ static int qpa_ctl_in (HWVoiceIn *hw, int cmd, ...)
 #endif
 
     switch (cmd) {
-    case VOICE_VOLUME:
+        case VOICE_VOLUME:
         {
             SWVoiceIn *sw;
             va_list ap;
@@ -613,8 +613,8 @@ static int qpa_ctl_in (HWVoiceIn *hw, int cmd, ...)
             pa_threaded_mainloop_lock (g->mainloop);
 
             op = pa_context_set_source_output_volume (g->context,
-                pa_stream_get_index (pa->stream),
-                &v, NULL, NULL);
+                                                      pa_stream_get_index (pa->stream),
+                                                      &v, NULL, NULL);
             if (!op) {
                 qpa_logerr (pa_context_errno (g->context),
                             "set_source_output_volume() failed\n");
@@ -623,8 +623,8 @@ static int qpa_ctl_in (HWVoiceIn *hw, int cmd, ...)
             }
 
             op = pa_context_set_source_output_mute (g->context,
-                pa_stream_get_index (pa->stream),
-                sw->vol.mute, NULL, NULL);
+                                                    pa_stream_get_index (pa->stream),
+                                                    sw->vol.mute, NULL, NULL);
             if (!op) {
                 qpa_logerr (pa_context_errno (g->context),
                             "set_source_output_mute() failed\n");
@@ -701,9 +701,9 @@ static void *qpa_audio_init (void)
 
     return g;
 
-unlock_and_fail:
+    unlock_and_fail:
     pa_threaded_mainloop_unlock (g->mainloop);
-fail:
+    fail:
     AUD_log (AUDIO_CAP, "Failed to initialize PA context");
     qpa_audio_fini(g);
     return NULL;
@@ -730,94 +730,94 @@ static void qpa_audio_fini (void *opaque)
 }
 
 struct audio_option qpa_options[] = {
-    {
-        .name  = "BUFFER_SIZE_OUT",
-        .tag   = AUD_OPT_INT,
-        .valp  = &glob_conf.buffer_size_out,
-        .descr = "internal buffer size in frames for playback device"
-    },
-    {
-        .name  = "BUFFER_SIZE_IN",
-        .tag   = AUD_OPT_INT,
-        .valp  = &glob_conf.buffer_size_in,
-        .descr = "internal buffer size in frames for recording device"
-    },
-    {
-        .name  = "TLENGTH",
-        .tag   = AUD_OPT_INT,
-        .valp  = &glob_conf.tlength,
-        .descr = "playback buffer target length in frames"
-    },
-    {
-        .name  = "FRAGSIZE",
-        .tag   = AUD_OPT_INT,
-        .valp  = &glob_conf.fragsize,
-        .descr = "fragment length of recording device in frames"
-    },
-    {
-        .name  = "MAXLENGTH_IN",
-        .tag   = AUD_OPT_INT,
-        .valp  = &glob_conf.maxlength_in,
-        .descr = "maximum length of PA recording buffer in frames"
-    },
-    {
-        .name  = "ADJUST_LATENCY_OUT",
-        .tag   = AUD_OPT_BOOL,
-        .valp  = &glob_conf.adjust_latency_out,
-        .descr = "instruct PA to adjust latency for playback device"
-    },
-    {
-        .name  = "ADJUST_LATENCY_IN",
-        .tag   = AUD_OPT_BOOL,
-        .valp  = &glob_conf.adjust_latency_in,
-        .descr = "instruct PA to adjust latency for recording device"
-    },
-    {
-        .name  = "SERVER",
-        .tag   = AUD_OPT_STR,
-        .valp  = &glob_conf.server,
-        .descr = "server address"
-    },
-    {
-        .name  = "SINK",
-        .tag   = AUD_OPT_STR,
-        .valp  = &glob_conf.sink,
-        .descr = "sink device name"
-    },
-    {
-        .name  = "SOURCE",
-        .tag   = AUD_OPT_STR,
-        .valp  = &glob_conf.source,
-        .descr = "source device name"
-    },
-    { /* End of list */ }
+        {
+                .name  = "BUFFER_SIZE_OUT",
+                .tag   = AUD_OPT_INT,
+                .valp  = &glob_conf.buffer_size_out,
+                .descr = "internal buffer size in frames for playback device"
+        },
+        {
+                .name  = "BUFFER_SIZE_IN",
+                .tag   = AUD_OPT_INT,
+                .valp  = &glob_conf.buffer_size_in,
+                .descr = "internal buffer size in frames for recording device"
+        },
+        {
+                .name  = "TLENGTH",
+                .tag   = AUD_OPT_INT,
+                .valp  = &glob_conf.tlength,
+                .descr = "playback buffer target length in frames"
+        },
+        {
+                .name  = "FRAGSIZE",
+                .tag   = AUD_OPT_INT,
+                .valp  = &glob_conf.fragsize,
+                .descr = "fragment length of recording device in frames"
+        },
+        {
+                .name  = "MAXLENGTH_IN",
+                .tag   = AUD_OPT_INT,
+                .valp  = &glob_conf.maxlength_in,
+                .descr = "maximum length of PA recording buffer in frames"
+        },
+        {
+                .name  = "ADJUST_LATENCY_OUT",
+                .tag   = AUD_OPT_BOOL,
+                .valp  = &glob_conf.adjust_latency_out,
+                .descr = "instruct PA to adjust latency for playback device"
+        },
+        {
+                .name  = "ADJUST_LATENCY_IN",
+                .tag   = AUD_OPT_BOOL,
+                .valp  = &glob_conf.adjust_latency_in,
+                .descr = "instruct PA to adjust latency for recording device"
+        },
+        {
+                .name  = "SERVER",
+                .tag   = AUD_OPT_STR,
+                .valp  = &glob_conf.server,
+                .descr = "server address"
+        },
+        {
+                .name  = "SINK",
+                .tag   = AUD_OPT_STR,
+                .valp  = &glob_conf.sink,
+                .descr = "sink device name"
+        },
+        {
+                .name  = "SOURCE",
+                .tag   = AUD_OPT_STR,
+                .valp  = &glob_conf.source,
+                .descr = "source device name"
+        },
+        { /* End of list */ }
 };
 
 static struct audio_pcm_ops qpa_pcm_ops = {
-    .init_out = qpa_init_out,
-    .fini_out = qpa_fini_out,
-    .run_out  = qpa_run_out,
-    .write    = qpa_write,
-    .ctl_out  = qpa_ctl_out,
-
-    .init_in  = qpa_init_in,
-    .fini_in  = qpa_fini_in,
-    .run_in   = qpa_run_in,
-    .read     = qpa_read,
-    .ctl_in   = qpa_ctl_in
+        .init_out = qpa_init_out,
+        .fini_out = qpa_fini_out,
+        .run_out  = qpa_run_out,
+        .write    = qpa_write,
+        .ctl_out  = qpa_ctl_out,
+
+        .init_in  = qpa_init_in,
+        .fini_in  = qpa_fini_in,
+        .run_in   = qpa_run_in,
+        .read     = qpa_read,
+        .ctl_in   = qpa_ctl_in
 };
 
 struct audio_driver pa_audio_driver = {
-    .name           = "pa",
-    .descr          = "http://www.pulseaudio.org/",
-    .options        = qpa_options,
-    .init           = qpa_audio_init,
-    .fini           = qpa_audio_fini,
-    .pcm_ops        = &qpa_pcm_ops,
-    .can_be_default = 1,
-    .max_voices_out = INT_MAX,
-    .max_voices_in  = INT_MAX,
-    .voice_size_out = sizeof (PAVoiceOut),
-    .voice_size_in  = sizeof (PAVoiceIn),
-    .ctl_caps       = VOICE_VOLUME_CAP
+        .name           = "pa",
+        .descr          = "http://www.pulseaudio.org/",
+        .options        = qpa_options,
+        .init           = qpa_audio_init,
+        .fini           = qpa_audio_fini,
+        .pcm_ops        = &qpa_pcm_ops,
+        .can_be_default = 1,
+        .max_voices_out = INT_MAX,
+        .max_voices_in  = INT_MAX,
+        .voice_size_out = sizeof (PAVoiceOut),
+        .voice_size_in  = sizeof (PAVoiceIn),
+        .ctl_caps       = VOICE_VOLUME_CAP
 };
-- 
2.15.0

